#!/usr/bin/env perl
use strict;
use warnings;
use autodie;
use IO::Handle;

# We need to talk to the user directly. stdin and stdout are what we're
# filtering.
open my $in,  '<', '/dev/tty';
open my $out, '>', '/dev/tty';
$out->autoflush(1);

my @lines;
my @is_selected;
my $cursor = 0;
my $done = 0;
my $counted = 0;

my %command_table = (
    j => sub { ++$cursor },
    k => sub { --$cursor if $cursor > 0 },
    y => sub { $is_selected[$cursor] = 1; ++$cursor },
    n => sub { $is_selected[$cursor] = 0; ++$cursor },
    d => sub { $done = 1 },
    q => sub { exit },
    c => sub {
        return if $counted;
        push @lines, <>;
        $counted = 1;
    },
);

$command_table{'?'} = sub {
    my $keys = join '', sort keys %command_table;
    tell_user("Valid commands are: $keys\n");
};

while (!$done) {
    # If the cursor is beyond the already-read lines, lazily read the next
    # line.
    push @lines, scalar <> until @lines > $cursor;

    # We hit EOF, so we're done getting input from the user.
    last if !defined($lines[-1]);

    # Default command.
    my $default = default_command();

    prompt_user($default);

    # Get some input.
    my $c = read_key();

    # We always want to add a blank line before any more output, since our
    # prompt didn't add a newline.
    tell_user("\n");

    # Space uses the default.
    $c = $default if $c eq ' ';

    # Run the command (or on invalid commands, show some help)
    $c = '?' if !exists($command_table{$c});
    $command_table{$c}->();
}

# Print selected lines!
print map { $lines[$_] }
      grep { $is_selected[$_] }
      0 .. $#lines;

sub read_key {
    # Term::ReadKey operates on STDIN.
    local *STDIN = $in;

    use Term::ReadKey;
    ReadMode(3); # Single-character input, without echo
    my $c = ReadKey;
    ReadMode(0); # Restore regular readline

    return $c;
}

sub tell_user {
    print { $out } @_;
}

sub prompt_user {
    my $default = shift;

    # current line
    tell_user($lines[$cursor]);

    tell_user("Shall I pass this line through? ");

    my $max = $counted ? @lines : '?';
    tell_user("($cursor/$max) ");

    # Construct the list of available commands.
    my $keys = join '',
               map { $_ eq $default ? uc($default) : $_ }
               sort
               grep { $_ ne '?' } # Don't display help command
               keys %command_table;

    tell_user("[$keys]> ");
}

sub default_command { $is_selected[$cursor] ? 'y' : 'n' }

