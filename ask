#!/usr/bin/env perl
use strict;
use warnings;
use autodie;
use IO::Handle;

# It's not very useful to have the user type in lines to then select...
exit if -t *STDIN;

# We need to talk to the user directly. stdin and stdout are what we're
# filtering.
open my $in,  '<', '/dev/tty';
open my $out, '>', '/dev/tty';
$out->autoflush(1);

my @lines;
my @is_selected;
my $cursor = 0;
my $done = 0;
my $counted = 0;

my %command_table = (
    j => sub { ++$cursor },
    k => sub { --$cursor if $cursor > 0 },
    y => sub { $is_selected[$cursor] = 1; ++$cursor },
    n => sub { $is_selected[$cursor] = 0; ++$cursor },
    d => sub { $done = 1 },
    q => sub { exit },
    c => sub {
        return if $counted;

        # Force the rest of stdin, so we can get a count of how many lines need
        # to be decided upon
        push @lines, <>;

        $counted = 1;
    },
);

while (!$done) {
    my $c = get_input();
    last if !defined($c);

    run_command($c);
}

# Print selected lines!
print map { $lines[$_] }
      grep { $is_selected[$_] }
      0 .. $#lines;

sub get_input {
    # If the cursor is beyond the already-read lines, lazily read the next
    # line.
    push @lines, scalar <> until @lines > $cursor;

    # We hit EOF, so we're done getting input from the user.
    return if !defined($lines[-1]);

    prompt_user();

    my $c = read_key();

    # We always want to add a blank line before any more output, since our
    # prompt didn't add a newline.
    tell_user("\n");

    return $c;
}

sub run_command {
    my $c = shift;

    # Space uses the default.
    $c = default_command() if $c eq ' ';

    return tell_user("Invalid response, try again!")
        if !exists($command_table{$c});

    $command_table{$c}->();
}

sub read_key {
    # Term::ReadKey operates on STDIN.
    local *STDIN = $in;

    use Term::ReadKey;
    ReadMode(3); # Single-character input, without echo
    my $c = ReadKey;
    ReadMode(0); # Restore regular readline

    return $c;
}

sub tell_user {
    print { $out } @_;
}

sub prompt_user {
    # current line
    tell_user($lines[$cursor]);

    tell_user("Shall I pass this line through? ");

    my $current = $cursor + 1; # start from 1 not 0
    my $max     = $counted ? @lines : '?';
    tell_user("($current/$max) ");

    my $default = default_command();

    # Construct the list of available commands.
    my $keys = join '',
               map { $_ eq $default ? uc($default) : $_ }
               sort
               grep { $_ ne '?' } # Don't display help command
               keys %command_table;

    tell_user("[$keys]> ");
}

sub default_command { $is_selected[$cursor] ? 'y' : 'n' }

